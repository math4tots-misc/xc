from . import lexer
from . import err

PREFIX = r"""// <Autogenerated from xc source>
// requires C++11
// xcs_* -> xc struct type
// xct_* -> xc type
// xcf_* -> xc function
// xcm_* -> xc method
// xcv_* -> xc variable
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

typedef void xct_Void;
typedef bool xct_Bool;
typedef char xct_Char;
typedef long long xct_Int;
typedef double xct_Float;

struct Root {
  int refcnt = 0;
  virtual ~Root() {}
  void increment_refcnt() { refcnt++; }
  void decrement_refcnt() {
    refcnt--;
    if (refcnt <= 0)
      delete this;
  }
};

template <class T>
struct SharedPtr {
  static_assert(
      std::is_base_of<Root, T>::value,
      "Template argument to SharedPtr must be derived from struct 'Root'");

  typedef T Pointee;

  SharedPtr(): ptr(nullptr) {}
  SharedPtr(T* p): ptr(p) { ptr->increment_refcnt(); }
  SharedPtr(const SharedPtr<T>& p): ptr(p.ptr) { ptr->increment_refcnt(); }
  ~SharedPtr() { ptr->decrement_refcnt(); }
  SharedPtr& operator=(const SharedPtr& p) {
    if (ptr != p.ptr) {
      if (ptr != nullptr)
        ptr->decrement_refcnt();
      ptr = p.ptr;
      ptr->increment_refcnt();
    }
    return *this;
  }
  T* operator->() { return ptr; }

private:
  T* ptr;
};

struct xcs_String;
using xct_String = SharedPtr<xcs_String>;
struct xcs_String: Root {
  const std::string data;
  xcs_String() {}
  xcs_String(const std::string& d): data(d) {}
};

template <class T> struct xcs_List;
template <class T> using xct_List = SharedPtr<xcs_List<T>>;
template <class T> struct xcs_List: Root {
  std::vector<T> data;

  xct_List<T> xcm_add(T t) {
    data.push_back(t);
    return xct_List<T>(this);
  }

  xct_Int xcm_size() const {
    return data.size();
  }
};

xct_Void xcf_print(xct_String text) {
  std::cout << text->data << std::endl;
}

xct_Void xcf_main();
int main() {
  xcf_main();
}"""

def translate(source):
  return Translator(source).translate()


class Translator(object):

  def __init__(self, source):
    self.source = source
    self.tokens = lexer.lex(source)
    self.i = 0

  def peek(self):
    return self.tokens[self.i]

  def gettok(self):
    self.i += 1
    return self.tokens[self.i-1]

  def at(self, type_):
    return self.peek().type == type_

  def consume(self, type_):
    if self.at(type_):
      return self.gettok()

  def expect(self, type_):
    if self.at(type_):
      return self.gettok()
    else:
      raise err.Err(
          'Expected token of type %r but found %r' % (
              type_, self.peek()),
          self.peek())

  ##############

  def translate(self):
    # a = class/type forward declarations
    # b = declarations
    # c = main source
    a, b, c = self.parse_program()
    return '\n//////////////'.join((PREFIX, a, b, c))

  def parse_program(self):
    a = b = c = ''
    while not self.at('EOF'):
      if self.at('fn'):
        x, y, z = self.parse_function()
        a += x
        b += y
        c += z
      else:
        raise err.Err('Expected function', self.peek())
    return a, b, c

  def parse_function(self):
    self.expect('fn')
    name = 'xcf_' + self.expect('ID').value
    args = self.parse_arg_sig()
    type_ = 'xct_Void' if self.at('{') else self.parse_type()
    body = self.parse_block()
    sig = '%s %s(%s)' % (type_, name, args)
    return '', '\n%s;' % sig, '\n%s%s' % (sig, body)

  def parse_type(self):
    name = 'xct_' + self.expect('ID').value
    if self.at('('):
      return '%s<%s>' % (name, parse_typeargs())
    else:
      return name

  def parse_statement(self):
    if self.consume('break'):
      return '\nbreak;'
    elif self.consume('continue'):
      return '\ncontinue;'
    elif self.at('{'):
      return self.parse_block()
    else:
      return '\n%s;' % self.parse_expression()

  def parse_expression(self):
    token = self.peek()
    if self.at('ID'):
      name = self.expect('ID').value
      if self.at('(') or self.at('['):
        if self.at('('):
          typeargs = self.parse_typeargs()
          args = self.parse_args()
          return 'xcf_%s<%s>(%s)' % (name, typeargs, args)
        else:
          args = self.parse_args()
          return 'xcf_%s(%s)' % (name, args)
      else:
        return 'xcv_' + name
    elif self.at('INT'):
      return self.expect('INT').value + 'LL'
    elif self.at('FLT'):
      return self.expect('FLT').value
    elif self.at('STR'):
      return 'xct_String(new xcs_String("%s"))' % (
          sanitize_string(eval(self.expect('STR').value)),)
    else:
      raise err.Err('Expected expression', token)

  def parse_block(self):
    self.expect('{')
    stmts = []
    while not self.consume('}'):
      stmts.append(self.parse_statement())
      while self.consume(';'):
        pass
    return '\n{%s\n}' % ''.join(stmts).replace('\n', '\n  ')

  def parse_arg_sig(self):
    self.expect('[')
    args = []
    while not self.consume(']'):
      name = self.expect('ID').value
      type_ = self.parse_type()
      args.append('%s %s' % (type_, name))
      self.consume(',')
    return ', '.join(args)

  def parse_typeargs(self):
    self.expect('(')
    args = []
    while not self.consume(')'):
      args.append(self.parse_type())
      self.consume(',')
    return ', '.join(args)

  def parse_args(self):
    self.expect('[')
    args = []
    while not self.consume(']'):
      args.append(self.parse_expression())
      self.consume(',')
    return ', '.join(args)


def sanitize_string(s):
  return (s
      .replace('\n', '\\n')
      .replace('\t', '\\t')
      .replace('"', '\\"')
      .replace("'", "\\'"))
