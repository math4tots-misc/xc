// <Autogenerated from xc source>
// requires C++11
// xcs_* -> xc struct type
// xct_* -> xc type
// xcf_* -> xc function
// xcm_* -> xc method
// xcv_* -> xc variable
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

typedef void xct_Void;
typedef bool xct_Bool;
typedef char xct_Char;
typedef long long xct_Int;
typedef double xct_Float;

struct Root {
  int refcnt = 0;
  virtual ~Root() {}
  void increment_refcnt() { refcnt++; }
  void decrement_refcnt() {
    refcnt--;
    if (refcnt <= 0)
      delete this;
  }
};

template <class T>
struct SharedPtr {
  static_assert(
      std::is_base_of<Root, T>::value,
      "Template argument to SharedPtr must be derived from struct 'Root'");

  typedef T Pointee;

  SharedPtr(): ptr(nullptr) {}
  SharedPtr(T* p): ptr(p) { ptr->increment_refcnt(); }
  SharedPtr(const SharedPtr<T>& p): ptr(p.ptr) { ptr->increment_refcnt(); }
  ~SharedPtr() { ptr->decrement_refcnt(); }
  SharedPtr& operator=(const SharedPtr& p) {
    if (ptr != p.ptr) {
      if (ptr != nullptr)
        ptr->decrement_refcnt();
      ptr = p.ptr;
      ptr->increment_refcnt();
    }
    return *this;
  }
  T* operator->() { return ptr; }

private:
  T* ptr;
};

struct xcs_String;
using xct_String = SharedPtr<xcs_String>;
struct xcs_String: Root {
  const std::string data;
  xcs_String() {}
  xcs_String(const std::string& d): data(d) {}
};

template <class T> struct xcs_List;
template <class T> using xct_List = SharedPtr<xcs_List<T>>;
template <class T> struct xcs_List: Root {
  std::vector<T> data;

  xct_List<T> xcm_add(T t) {
    data.push_back(t);
    return xct_List<T>(this);
  }

  xct_Int xcm_size() const {
    return data.size();
  }
};

xct_Void xcf_print(xct_String text) {
  std::cout << text->data << std::endl;
}

xct_Void xcf_main();
int main() {
  xcf_main();
}
//////////////
//////////////
xct_Void xcf_main();
//////////////
xct_Void xcf_main()
{
  xcf_print(xct_String(new xcs_String("Hello world!")));
}
