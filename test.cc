// <Autogenerated from xc source>
// requires C++11
// xcs_* -> xc struct type
// xct_* -> xc type
// xcf_* -> xc function
// xcm_* -> xc method
// xca_* -> xc attribute (member variable)
// xcv_* -> xc variable
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

typedef void xct_Void;
typedef bool xct_Bool;
typedef char xct_Char;
typedef long long xct_Int;
typedef double xct_Float;

struct Root {
  int refcnt = 0;
  virtual ~Root() {}
  void increment_refcnt() { refcnt++; }
  void decrement_refcnt() {
    refcnt--;
    if (refcnt <= 0)
      delete this;
  }
};

template <class T>
struct SharedPtr {
  static_assert(
      std::is_base_of<Root, T>::value,
      "Template argument to SharedPtr must be derived from struct 'Root'");

  typedef T Pointee;

  SharedPtr(): ptr(nullptr) {}
  SharedPtr(T* p): ptr(p) { ptr->increment_refcnt(); }
  SharedPtr(const SharedPtr<T>& p): ptr(p.ptr) { ptr->increment_refcnt(); }
  ~SharedPtr() { ptr->decrement_refcnt(); }
  SharedPtr& operator=(const SharedPtr& p) {
    if (ptr != p.ptr) {
      if (ptr != nullptr)
        ptr->decrement_refcnt();
      ptr = p.ptr;
      ptr->increment_refcnt();
    }
    return *this;
  }
  T* operator->() { return ptr; }

  SharedPtr<T> operator+(SharedPtr<T> other) {
    return ptr->operator_add(other);
  }

private:
  T* ptr;
};

struct xcs_String;
using xct_String = SharedPtr<xcs_String>;
struct xcs_String: Root {
  const std::string data;
  xcs_String() {}
  xcs_String(const std::string& d): data(d) {}

  xct_String operator_add(xct_String other) {
    return new xcs_String(data + other->data);
  }
};

template <class T> struct xcs_List;
template <class T> using xct_List = SharedPtr<xcs_List<T>>;
template <class T> struct xcs_List: Root {
  std::vector<T> data;

  xct_List<T> xcm_add(T t) {
    data.push_back(t);
    return xct_List<T>(this);
  }

  xct_Int xcm_size() const {
    return data.size();
  }
};

template <class T>
xct_String xcf_str(T t) {
  return t->operator_str();
}

template <>
xct_String xcf_str(xct_String t) {
  return t;
}

template <>
xct_String xcf_str(xct_Int t) {
  return new xcs_String(std::to_string(t));
}

template <class T>
xct_Void xcf_print(T t) {
  std::cout << xcf_str(t)->data << std::endl;
}

xct_Void xcf_main();
int main() {
  xcf_main();
}
//////////////
//////////////
xct_Void xcf_main();
template <class xct_T>
xct_Void xcf_sample(xct_T xcv_t);
//////////////
xct_Void xcf_main()
{
  xcf_print(xct_String(new xcs_String("Hello world!")));
  xcf_print(5LL + 7LL);
  xcf_sample(1234LL - 7LL);
}
template <class xct_T>
xct_Void xcf_sample(xct_T xcv_t)
{
  xcf_print(xct_String(new xcs_String("Hi ")) + xcf_str(xcv_t));
}
